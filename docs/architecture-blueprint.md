# 全栈架构设计文档（V2 详细版）

更新时间：2026-02-23  
文档状态：可进入实现  
目标读者：你本人、代码评审者（Claude Code）、后续协作开发者

---

## 1. 文档定位与边界

### 1.1 文档目标

1. 给出一个“不是玩具”的可落地架构，支持 MVP 快速交付。
2. 明确未来扩展路径，避免后期重写核心流程。
3. 固化前后端契约、扩展点、边界条件和关键取舍。
4. 让评审者可以直接按本文件进行架构 review。

### 1.2 文档不做什么

1. 不替代 PRD（业务目标与范围以 `prd.md` 为准）。
2. 不替代逐字段 API 文档（后续单独维护 `docs/api-contract.md`）。
3. 不绑定某个云平台（保持本地优先、可迁移）。

### 1.3 相关文档

1. 产品需求：`prd.md`
2. 技术设计：`docs/technical-design.md`
3. 依赖清单：`docs/dependency-checklist.md`
4. 安装手册：`docs/install-guide-windows.md`
5. 启动手册：`docs/startup-runbook.md`
6. 任务跟踪：`localDoc/TODO.md`

---

## 2. 架构目标、非目标与质量属性

### 2.1 架构目标（必须同时满足）

1. **可复现**：同数据 + 同参数 + 同随机种子 = 同结果。
2. **可扩展**：新增策略不改主流程，只加策略模块与注册。
3. **可解释**：结果可追溯到数据版本、引擎版本、参数快照。
4. **可维护**：模块边界清晰，注释规范严格执行。
5. **可演示**：前端体验完整，后端链路可靠，报告可导出。

### 2.2 架构非目标（当前阶段刻意不做）

1. 多租户账号体系与复杂权限。
2. 分布式微服务部署。
3. 高频交易级别低延迟系统。
4. 多资产全市场统一引擎（仅聚焦 A 股 ETF）。

### 2.3 关键质量属性与目标值

| 维度 | 目标值 | 说明 |
| --- | --- | --- |
| 可复现性 | 100% 重复一致 | 固定随机种子与数据快照 |
| 单次回测性能 | 5 年日频 <= 3s | 本地普通机器 |
| 100 次实验性能 | <= 30s | 本地批量实验 |
| 可用性 | 本地离线可运行核心链路 | AI 可降级 |
| 可维护性 | 模块职责单一、注释完整 | 新策略接入成本可控 |

---

## 3. 全局约束与设计原则

### 3.1 全局约束

1. 前端：React + TypeScript（函数组件 + Hooks）。
2. 后端：Python + FastAPI（清晰分层）。
3. 前后端分离，但同仓库组织（Monorepo）。
4. 强注释规范：文件头、函数注释、字段语义注释。
5. 依赖安装由你在 Windows 执行，助手只提供文档与代码。

### 3.2 设计原则

1. **稳定优先**：先做可验证、可追溯，再谈复杂能力。
2. **扩展靠接口，不靠 if/else**：策略、数据源、模型接入统一协议。
3. **结果对象统一**：前端与 AI 只依赖统一 schema。
4. **避免过度设计**：仅在明确收益场景引入复杂机制。
5. **演进式架构**：MVP 先单体分层，达到阈值再服务拆分。

---

## 4. 系统全景与运行拓扑

### 4.1 逻辑组件

1. Frontend SPA（参数配置、结果展示、实验分析、报告查看）。
2. Backend API（路由、编排、领域引擎、数据访问）。
3. Data Provider Adapter（AkShare/TuShare 适配层）。
4. Backtest Engine（策略执行、成本计算、指标计算）。
5. Experiment Runner（随机实验与分布统计）。
6. Report Service（Prompt 构建、模型调用、结果清洗）。
7. Local Storage（SQLite + 文件缓存）。

### 4.2 运行时关系（简化时序）

1. 前端提交参数至 `/api/backtests/run`。
2. 后端拉取并标准化行情数据。
3. 引擎执行策略，产出统一结果对象。
4. 后端落库运行记录，返回 `run_id` 与结果快照。
5. 前端基于 `run_id` 请求实验与报告能力。
6. 报告服务读取结构化结果，调用 LLM provider，返回长报告。

---

## 5. 仓库与目录结构设计

### 5.1 顶层目录

```text
cx回测/
  frontend/
  backend/
  docs/
  localDoc/
```

### 5.2 前端目录建议（详细）

```text
frontend/
  src/
    app/
      router.tsx
      providers.tsx
    pages/
      backtest/
      experiments/
      reports/
    features/
      backtest-config/
      backtest-result/
      experiment-panel/
      report-panel/
    components/
      charts/
      forms/
      feedback/
    hooks/
      useBacktestRunner.ts
      useExperimentRunner.ts
    services/
      httpClient.ts
      backtestApi.ts
      experimentApi.ts
      reportApi.ts
    types/
      api.ts
      domain.ts
    utils/
      formatters.ts
      guards.ts
```

### 5.3 后端目录建议（详细）

```text
backend/
  app/
    main.py
    api/
      routers/
        etf_router.py
        backtest_router.py
        experiment_router.py
        report_router.py
      deps.py
      error_handlers.py
    schemas/
      common.py
      backtest.py
      experiment.py
      report.py
    services/
      backtest_service.py
      experiment_service.py
      report_service.py
      run_query_service.py
    domain/
      strategies/
        base.py
        dca_strategy.py
        registry.py
      engine/
        backtest_engine.py
        portfolio.py
        order_executor.py
      metrics/
        risk_metrics.py
        return_metrics.py
      models/
        market_bar.py
        signal.py
        run_result.py
    infra/
      data_sources/
        base.py
        akshare_provider.py
      ai/
        base_provider.py
        openai_provider.py
      persistence/
        sqlite.py
        repositories/
          run_repository.py
      cache/
        file_cache.py
    core/
      config.py
      logger.py
      constants.py
      exceptions.py
```

---

## 6. 后端架构详细设计

### 6.1 分层职责与依赖规则

1. `api` 只做输入输出编排，不做核心计算。
2. `services` 负责编排用例，不依赖具体 Web 框架细节。
3. `domain` 只保留纯业务逻辑，不依赖外部服务。
4. `infra` 提供外部实现（数据源、模型、数据库）。
5. `core` 放配置、异常、日志等跨层能力。

依赖方向：`api -> services -> domain`，`services -> infra`，禁止反向依赖。

### 6.2 核心用例流（后端）

#### 6.2.1 单次回测

1. 校验请求参数与策略参数。
2. 获取行情数据（缓存优先，源接口兜底）。
3. 构建策略上下文并执行引擎。
4. 计算指标并组装统一结果。
5. 写入运行记录（输入、输出、版本、耗时）。
6. 返回结果。

#### 6.2.2 随机实验

1. 读取基础回测参数与实验参数。
2. 生成 N 组采样窗口（可复现 seed）。
3. 对每组窗口调用同一回测引擎。
4. 聚合统计（均值、标准差、分位数、极值）。
5. 保存实验记录并返回聚合结果。

#### 6.2.3 AI 报告

1. 读取回测结果与实验摘要。
2. 构建结构化 Prompt（包含章节模板）。
3. 调用主模型，失败则按策略降级。
4. 清洗输出并加上元数据（模型、token、耗时）。
5. 保存报告记录并返回。

### 6.3 策略引擎设计（可扩展核心）

#### 6.3.1 Strategy 接口（必须）

1. `name`：策略标识。
2. `version`：策略版本。
3. `validate_params(params)`：参数校验。
4. `on_bar(ctx)`：逐 bar 输出 `BUY/SELL/HOLD`。

#### 6.3.2 StrategyContext（建议字段）

1. 当前日期与行情切片。
2. 当前现金、持仓份额、持仓成本。
3. 交易规则（费率、最小费用、税费规则）。
4. 回测配置（调仓频率、交易价格模式）。

#### 6.3.3 StrategySignal（建议字段）

1. `action`：买/卖/持有。
2. `quantity` 或 `amount`：下单规模。
3. `reason`：策略解释文本（便于回溯与调试）。

#### 6.3.4 策略注册中心

1. 启动时进行注册：`strategy_name -> strategy class`。
2. 运行时仅通过注册中心创建策略实例。
3. 新增策略只新增文件 + 注册，不改主引擎。

### 6.4 数据源适配层设计

#### 6.4.1 Provider 接口

1. `search_symbols(keyword)`：检索 ETF。
2. `fetch_bars(symbol, start, end, adjust)`：拉取行情。
3. `health_check()`：源可用性检测。

#### 6.4.2 标准化输出模型

统一输出 `MarketBar`：

1. `trade_date`
2. `open/high/low/close`
3. `volume/amount`
4. `source`
5. `adjust_type`

#### 6.4.3 缓存策略

1. 查询缓存键：`symbol+date_range+adjust_type+source_version`。
2. 本地文件缓存 + TTL（按交易日刷新）。
3. 源失败时可使用近期缓存并返回“降级标记”。

### 6.5 成本模型与指标模型

#### 6.5.1 成本模型（MVP）

1. 佣金（可配置比例 + 最小费用）。
2. 印花税（按市场规则，仅卖出或按配置）。
3. 过户费（按市场规则或配置）。

#### 6.5.2 指标模块分组

1. 收益类：累计收益、年化收益。
2. 风险类：波动率、最大回撤。
3. 风险调整类：夏普比率。

#### 6.5.3 版本化要求

1. `metric_definition_version` 必须随结果返回。
2. 指标公式改动必须递增版本并写入变更记录。

### 6.6 持久化模型设计（SQLite）

#### 6.6.1 `runs`（回测主记录）

1. `id`：运行 ID。
2. `run_type`：`single_backtest` / `experiment` / `report`。
3. `status`：`success` / `failed`。
4. `input_snapshot_json`：输入快照。
5. `result_json`：结果对象。
6. `engine_version`：引擎版本。
7. `created_at`：创建时间。
8. `duration_ms`：耗时。

#### 6.6.2 `reports`（报告记录）

1. `id`
2. `run_id`（关联回测或实验）
3. `model_provider`
4. `model_name`
5. `prompt_version`
6. `report_text`
7. `created_at`

#### 6.6.3 保留与归档策略

1. MVP 默认本地全量保留。
2. 当数据量上升时按时间归档 JSON。
3. 导出能力优先于复杂归档系统。

### 6.7 API 设计规范（统一约束）

1. URL 前缀统一 `/api`。
2. 响应结构统一：
   - `code`
   - `message`
   - `data`
   - `request_id`
3. 关键返回必须包含：
   - `input_snapshot`
   - `engine_version`
   - `metric_definition_version`
4. 错误码分层：
   - `4xx` 参数/业务错误
   - `5xx` 系统/依赖错误

### 6.8 幂等与一致性

1. 回测与实验请求可选 `idempotency_key`。
2. 相同 `idempotency_key + payload_hash` 直接返回历史结果。
3. 幂等记录先落内存/SQLite，避免重复重算。

### 6.9 异常处理策略

1. 业务异常：返回可读中文提示 + 错误码。
2. 外部依赖异常：记录详细日志，前端返回可行动建议。
3. 未知异常：屏蔽敏感栈信息，但保留 `request_id` 便于排查。

---

## 7. 前端架构详细设计

### 7.1 前端核心目标

1. 参数输入可靠、反馈明确、错误可恢复。
2. 图表展示清晰，能支持面试讲解场景。
3. API 类型对齐，避免字段漂移。

### 7.2 路由与页面结构（MVP）

1. `/backtest`：参数配置与运行入口。
2. `/result/:runId`：单次回测详情。
3. `/experiments/:runId`：实验统计与分布展示。
4. `/reports/:runId`：AI 报告查看与复制导出。

### 7.3 状态管理分层

1. 远程状态：React Query 管理缓存与请求状态。
2. 表单状态：React Hook Form + Zod 统一校验。
3. 页面局部状态：`useState/useReducer`。
4. 避免全局 store 过早引入，等跨页共享复杂化再评估。

### 7.4 API 调用层规范

1. `services/httpClient.ts` 统一处理超时、重试、错误映射。
2. 每个业务域单独 API 文件，禁止组件内直接 `fetch`。
3. 所有请求和响应类型在 `types/api.ts` 管理。

### 7.5 可视化组件设计

1. 净值曲线图组件。
2. 回撤曲线图组件。
3. 实验分布图组件（直方图/箱线图）。
4. 指标卡组件。
5. 表格组件（交易明细）。

### 7.6 交互反馈规范

1. 加载态：骨架屏或 loading 区块。
2. 空态：明确下一步行动提示。
3. 错误态：显示错误原因 + 可重试操作。
4. 长任务：显示进度文本或阶段提示。

### 7.7 前端扩展预留

1. 多策略动态表单渲染（未来从后端拉策略元数据）。
2. 多报告版本对比。
3. 回测结果快照对比页面。

---

## 8. AI 报告子系统详细设计

### 8.1 设计目标

1. 模型可替换。
2. 输出结构稳定。
3. 成本可控。
4. 失败可降级。

### 8.2 Provider 抽象

1. 统一接口：`generate(prompt, config) -> text`。
2. 实现层：`OpenAIProvider`、未来可扩 `OtherProvider`。
3. 配置化模型选择：`MODEL_PRIMARY`、`MODEL_FALLBACK`。

### 8.3 Prompt 模板管理

1. 模板版本化（`prompt_version`）。
2. 固定章节结构：
   - 摘要
   - 收益解释
   - 风险提示
   - 参数敏感性
   - 后续试验建议
3. 禁止自由发挥越权内容（不引入外部新闻结论）。

### 8.4 质量与安全控制

1. 对输入进行长度与字段校验。
2. 对输出进行结构检查与敏感词清洗（如有需要）。
3. 模型失败自动降级，降级失败返回明确错误。

---

## 9. 可观测性与运维设计

### 9.1 日志规范

1. 所有请求附带 `request_id`。
2. 核心运行附带 `run_id`。
3. 日志分级：`INFO/WARN/ERROR`。
4. 敏感信息脱敏（API Key、用户密钥）。

### 9.2 指标采集（MVP 轻量）

1. 回测耗时。
2. 实验总耗时与单次平均耗时。
3. 数据源失败率。
4. 报告调用成功率与平均耗时。

### 9.3 故障处理

1. 数据源故障：重试 + 缓存降级 + 用户提示。
2. 模型故障：降级模型 + 报错引导。
3. 数据库故障：快速失败并保留输入快照日志。

---

## 10. 安全与边界设计

### 10.1 当前边界（MVP）

1. 本地单用户，无复杂鉴权。
2. API 仅本地访问（默认开发模式）。
3. 关键密钥仅 `.env` 保存。

### 10.2 未来可扩展边界

1. 若部署公网，必须增加鉴权（JWT/API Key）。
2. 增加速率限制与请求签名。
3. 报告接口增加配额控制。

---

## 11. 测试策略（架构级）

### 11.1 后端测试分层

1. 单元测试：策略逻辑、成本模型、指标函数。
2. 集成测试：数据源适配 -> 引擎 -> API。
3. 契约测试：请求响应结构与字段语义。
4. 回归测试：固定数据快照 + 固定 seed。

### 11.2 前端测试分层

1. 组件测试：图表容器、表单、指标卡。
2. 页面测试：参数提交流程、错误处理流程。
3. 接口 mock 测试：MSW 驱动。

### 11.3 关键验收用例

1. 相同输入重复运行结果一致。
2. 新增策略后旧策略结果不受影响。
3. AI 报告模型切换不影响业务调用代码。
4. 数据源异常时前端能看到可行动提示。

---

## 12. 演进路线与拆分阈值

### 12.1 阶段 1（当前）

1. 单体分层架构（模块清晰，快速交付）。
2. 本地 SQLite + 文件缓存。
3. 单用户使用。

### 12.2 阶段 2（增长）

1. 数据与回测任务异步化（任务队列）。
2. 支持更多策略并引入策略元数据接口。
3. 引入更完整的日志与监控面板。

### 12.3 阶段 3（规模化）

1. 按职责拆服务：
   - 计算服务
   - 数据服务
   - 报告服务
2. 引入 PostgreSQL/Redis。
3. 增加用户体系与权限。

### 12.4 触发拆分的客观阈值

1. 单机计算耗时显著影响体验（例如 95 分位 > 60s）。
2. 模块发布节奏严重不同。
3. 需要独立扩容某一能力（如报告服务）。

---

## 13. 关键取舍与技术决策记录（ADR 摘要）

### ADR-001：单体分层 vs 微服务

1. 结论：MVP 用单体分层。
2. 原因：个人项目需要速度与可控复杂度。
3. 风险：后期拆分成本。
4. 缓解：严格模块边界 + 抽象接口。

### ADR-002：SQLite vs PostgreSQL

1. 结论：MVP 用 SQLite。
2. 原因：零运维、本地演示友好。
3. 风险：并发与规模上限。
4. 缓解：仓储层抽象，未来平滑切换。

### ADR-003：同步执行 vs 异步任务队列

1. 结论：MVP 以同步为主。
2. 原因：减少任务系统复杂度。
3. 风险：长任务阻塞体验。
4. 缓解：先做轻量进度提示，后续引入异步队列。

### ADR-004：固定策略配置页 vs 动态策略元数据

1. 结论：MVP 固定定投配置页。
2. 原因：当前仅单策略，动态表单会过度设计。
3. 风险：策略增多后 UI 扩展成本上升。
4. 缓解：提前定义策略元数据协议，后续切换。

---

## 14. 风险清单与应对策略（详细）

| 风险 | 严重性 | 触发信号 | 应对策略 |
| --- | --- | --- | --- |
| 数据源字段变更 | 高 | 解析报错率上升 | 适配层校验 + 回归测试 |
| 回测口径漂移 | 高 | 指标异常波动 | 版本化 + 快照回放 |
| 策略接口腐化 | 高 | 新策略改主流程 | 强制注册中心 + 代码评审 |
| AI 输出失控 | 中 | 报告风格漂移 | 模板化 + 输出校验 |
| 前后端字段漂移 | 高 | 前端渲染报错 | OpenAPI 契约驱动 |
| 过度抽象 | 中 | 开发速度明显下降 | 两次复用原则再抽象 |

---

## 15. 注释与编码规范落地（执行清单）

### 15.1 文件级

1. 每个非极简文件开头写用途说明：
   - 该文件负责什么
   - 被谁调用
   - 与其他模块边界

### 15.2 函数级

1. 每个非极简函数必须说明：
   - 作用
   - 入参
   - 出参
   - 可能异常

### 15.3 字段级

1. 请求体/响应体字段写业务语义。
2. 持久化字段写用途与约束。
3. 极简通用字段可省略，但不要省略关键业务字段。

---

## 16. 实施计划（架构到代码）

### 16.1 第一步：固化字段契约

1. 输出 `docs/api-contract.md`（逐接口字段）。
2. 输出 `docs/schema-dictionary.md`（核心对象字段字典）。

### 16.2 第二步：搭建工程骨架

1. 创建前后端目录和基础配置。
2. 创建后端分层文件与占位接口。
3. 创建前端页面骨架与 API 层。

### 16.3 第三步：贯通最小链路

1. 实现 ETF 查询。
2. 实现单次定投回测。
3. 实现结果页展示。

### 16.4 第四步：增强能力

1. 加随机实验。
2. 加 AI 报告。
3. 加导出与测试补齐。

---

## 17. 给 Claude Code 的评审清单

建议评审重点：

1. 模块边界是否存在反向依赖风险。
2. 策略扩展机制是否真的做到开闭原则。
3. 数据模型是否足够支撑未来多策略和多资产。
4. API 返回结构是否能长期稳定演进。
5. AI 子系统是否存在耦合过重或不可测风险。
6. 是否存在“为了未来而过度设计”的部分。

---

## 18. 当前已知待确认点（供你批注）

1. 随机实验是否需要支持并行执行（影响任务系统设计）。
2. 报告是否需要多语言输出（影响 Prompt 与模板设计）。
3. 是否在 MVP 内加入用户自定义无风险利率。
4. 是否引入策略回放可视化（K 线 + 信号点）。
5. 是否需要报告版本对比页面。

---

## 19. 最终结论

当前架构方案采用“**可扩展的单体分层**”：  
在不牺牲交付速度的前提下，已经为策略扩展、模型替换、数据源替换、服务拆分预留清晰接口和边界。  
若严格按本文件执行并保持注释规范，项目不会演变成玩具 Demo，而是可持续演进的个人量化工程底座。

